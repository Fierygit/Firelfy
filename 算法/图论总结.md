# <center>图论总结</center>

[toc]

### 图是什么？

![](https://raw.githubusercontent.com/Fierygit/picbed/master/20200219203748.png)

树可以存线， 图可以存树，树是一种无环图， 线是最简单的数据结构， 图是较为复杂的一种数据结构！



### 图的分类

|      |    有向    |    无向    |
| :--: | :--------: | :--------: |
| 有权 | 有向有权图 | 无向有权图 |
| 无权 | 有向无权图 | 无向无权图 |



### 图的表示

- 邻接矩阵

```c
int a[i][j] 
```

i点到j点的距离！ 空间复杂度： V^2 ,  求一个点的临接点:  V

- 邻接表（链表）

只存每个点能到达的点

空间复杂度： O（V+E  ），建图： O（E*V），求一个点的临接点：（O（V））

可以用 hash 或者 红黑树  替换 链表

```c++
const int maxn = 1e5 + 1;
struct Node{
    int to, cost;
}
// 无向无权图
vector<int> Graph1[maxn];
// 无向有权图
vector<Node> Graph2[maxn];
// hash 找很快！ 红黑树  to  cost  
map<int, int>Graph3[maxn];  // map 默认为0， 
// 邻接表
vaecotr<vector<int> > Graph4;
```



### 图的遍历

#### DFS

- 树

分为 前序， （二叉树）中序， 后序， ==不用记录遍历过的点==！

- 图

分为 先序，后续（基本不用），要记录每一个每一个点是否遍历过， visited 记录

模版：

```c++
// 递归
void dfs41(int index, bool *visited) {
  visited[index] = 1;
  cout << index << " -> ";  // 前序遍历
  for (int i = 0; i < len; i++) {
    if (!visited[i] && Graph4[index][i] != 0) {
      dfs41(i, visited);
    }
  }
  // cout << index << " -> ";后序遍历
}
```

```c++
// 非递归
void dfs42(int start) {
  stack<int> stack;
  stack.push(start);
  bool visited[len] = {0};
  while (!stack.empty()) {
    int temp = stack.top();
    stack.pop();
    visited[temp] = 1;
    cout << temp << " -> ";
    for (int i = 0; i < len; i++)
      if (!visited[i] && Graph4[temp][i] != 0) {
        stack.push(i);
        visited[i] = 1;
      }
  }
}
```

#### BFS

树的BFS和图的BFS是一样的！
**无权图的最短路径**

```c++
// 深度优先
void bfs4(int start) {
  queue<int> q;
  q.push(start);
  bool visited[len] = {0};
  while (!q.empty()) {
    int temp = q.front();
    q.pop();
    visited[temp] = 1;
    cout << temp << " -> ";
    for (int i = 0; i < len; i++)
      if (!visited[i] && Graph4[temp][i]) {
        visited[i] = 1;
        q.push(i);
      }
  }
}
```

#### 比较

做题最好用dfs， 基于递归不用容器（自带的栈）存储太多东西！

栈（DFS），队列（BFS）， 随机容器（迷宫生成！）

```c++
int rs_len = 20;
vint cap(rs_len);
int cap_len = 0;
//自己造一个随机容器！
bool cap_empty() { return cap_len == 0 ? 1 : 0; }
void cap_put(int value) { cap[cap_len++] = value; }
int cap_get() {
  if (cap_empty()) {
    cout << "error: out of index!\n";
    return -1;
  }
  srand(time(NULL));  // 随机获取一个数
  int index = rand() % cap_len;
  // cout << "random" << index << " " << cap_len << endl;
  int ret = cap[index];
  for (int i = index; i < cap_len - 1; i++) cap[i] = cap[i + 1];
  cap_len--;
  return ret;
}
void gen_map(vvint map);
// @param 迷宫的长度
void rs4(int len) {
  rs_len = len;
  vvint map(rs_len * rs_len, vint(rs_len * rs_len));
  for (int i = 0; i < rs_len; i++) {
    for (int j = 0; j < rs_len - 1; j++) {
      map[j + i * rs_len][j + i * rs_len + 1] = 1;
      map[j + i * rs_len + 1][j + i * rs_len] = 1;
      map[j * rs_len + i][(j * rs_len + i) + rs_len] = 1;
      map[j * rs_len + i + rs_len][j * rs_len + i] = 1;
    }
  }
  // 从 0 开始  随机搜索
  cap_put(0);
  bool visited[rs_len * rs_len] = {0};
  visited[0] = 1;
  while (!cap_empty()) {
    int temp = cap_get();
    for (int i = 0; i < rs_len * rs_len; i++)
      if (!visited[i] && map[temp][i] == 1) {
        //cout << temp << "  " << i << endl;
        map[temp][i] = map[i][temp] = 2;
        cap_put(i);
        visited[i] = 1;
      }
  }
  // traverse4(map);
  gen_map(map);
}
// 把遍历的经过转换成地图
void gen_map(vvint map) {
  vvint temp(rs_len * 2, vint(rs_len * 2));
  for (int i = 0; i < rs_len; i++) {
    for (int j = 0; j < rs_len - 1; j++) {
      if (map[j + i * rs_len][j + i * rs_len + 1] == 2) {  // 每一行
        //cout << i << " * " << j;
        //cout << " " << j + i * rs_len << " " << j + i * rs_len + 1 << endl;
        temp[i * 2][j * 2] = temp[i * 2][(j + 1) * 2] = temp[i * 2][j * 2 + 1] =
            1;
      }
      if (map[j * rs_len + i][(j * rs_len + i) + rs_len] == 2) {  // 每一列
        //cout << j << " / " << i;
        //cout << " " << j * rs_len + i << " " << j * rs_len + i + rs_len << endl;
        temp[j * 2][i * 2] = temp[(j + 1) * 2][i * 2] = temp[j * 2 + 1][i * 2] =
            1;
      }
    }
  }
  for (int i = 0; i < rs_len * 2 - 1; i++) {
    for (int j = 0; j < rs_len * 2 - 1; j++) {
      int out = (temp[i][j] == 1) ? 1 : 0;
      cout << out << "  ";
    }
    cout << endl;
  }
} //code 随机迷宫int rs_len = 20;vint cap(rs_len);int cap_len = 0;bool cap_empty() { return cap_len == 0 ? 1 : 0; }void cap_put(int value) { cap[cap_len++] = value; }int cap_get() {  if (cap_empty()) {    cout << "error: out of index!\n";    return -1;  }  srand(time(NULL));  // 随机获取一个数  int index = rand() % cap_len;  // cout << "random" << index << " " << cap_len << endl;  int ret = cap[index];  for (int i = index; i < cap_len - 1; i++) cap[i] = cap[i + 1];  cap_len--;  return ret;}void gen_map(vvint map);// @param 迷宫的长度void rs4(int len) {  rs_len = len;  vvint map(rs_len * rs_len, vint(rs_len * rs_len));  for (int i = 0; i < rs_len; i++) {    for (int j = 0; j < rs_len - 1; j++) {      map[j + i * rs_len][j + i * rs_len + 1] = 1;      map[j + i * rs_len + 1][j + i * rs_len] = 1;      map[j * rs_len + i][(j * rs_len + i) + rs_len] = 1;      map[j * rs_len + i + rs_len][j * rs_len + i] = 1;    }  }  // 从 0 开始  广度优先搜索  cap_put(0);  bool visited[rs_len * rs_len] = {0};  visited[0] = 1;  while (!cap_empty()) {    int temp = cap_get();    for (int i = 0; i < rs_len * rs_len; i++)      if (!visited[i] && map[temp][i] == 1) {        //cout << temp << "  " << i << endl;        map[temp][i] = map[i][temp] = 2;        cap_put(i);        visited[i] = 1;      }  }  // traverse4(map);  gen_map(map);}void gen_map(vvint map) {  vvint temp(rs_len * 2, vint(rs_len * 2));  for (int i = 0; i < rs_len; i++) {    for (int j = 0; j < rs_len - 1; j++) {      if (map[j + i * rs_len][j + i * rs_len + 1] == 2) {  // 每一行        //cout << i << " * " << j;        //cout << " " << j + i * rs_len << " " << j + i * rs_len + 1 << endl;        temp[i * 2][j * 2] = temp[i * 2][(j + 1) * 2] = temp[i * 2][j * 2 + 1] =            1;      }      if (map[j * rs_len + i][(j * rs_len + i) + rs_len] == 2) {  // 每一列        //cout << j << " / " << i;        //cout << " " << j * rs_len + i << " " << j * rs_len + i + rs_len << endl;        temp[j * 2][i * 2] = temp[(j + 1) * 2][i * 2] = temp[j * 2 + 1][i * 2] =            1;      }    }  }  for (int i = 0; i < rs_len * 2 - 1; i++) {    for (int j = 0; j < rs_len * 2 - 1; j++) {      int out = (temp[i][j] == 1) ? 1 : 0;      cout << out << "  ";    }    cout << endl;  }}c++
```



#### 应用

- 求联通分量（图分成了多少块！？）

```c++
//code
```

- 路径问题（从一个点到另一个点是否通？）回溯

```c++
//code
```

- 检测环

```c++
//code
```

- 二分图检测

![](https://raw.githubusercontent.com/Fierygit/picbed/master/20200219211503.png)

定点V可以分为两部分， 所有边的两个顶点分别属于这两部分！ 

```c++
//code(染色)
```



#### floodfill算法

把图联通的某一部分填满！

游戏开发 -> 扫雷， 最大人工岛屿

```c++
//code
```



### 桥和隔点

> 桥： 删除了某一条边，联通分量发生改变！

![](https://raw.githubusercontent.com/Fierygit/picbed/master/20200219215253.png)

寻找所有桥！只有DFS可以求！(dfs遍历树)

对于每一条边 v - w ， 通过w， 能否通过另一条路回到v

```c++
//code  难
```



> 隔点： 删除隔点， 图的联通分量产生变化！

类似寻找桥的算法！

```c++
//code
```



### 欧拉回路和欧拉路径

哈密尔顿回路

从一个点出发， 经过**每个点一次**，回到原点

欧拉回路

从一条点出发， 经过**每一条边一次**， 回到原点

// 离散数学知识， 不会考

##### 状态压缩

 无权图可以直接使用**位**来存储图

### 最小生成树

#### 并查集

#### Kruskal

```c++

```

#### prim

```c++

```



### 最短路径

#### dijkstra和单源最短路径

无负数

```c++

```



#### Bellman-Ford

负数

```c++

```





#### Floyed-Warshall

所有点对最短路径





### 拓扑排序



```c++

```





### 网络流和最大流



#### Ford-Fulkerson



#### Edmonds-Karp





#### 匈牙利算法

BFS



DFS