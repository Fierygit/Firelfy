# <center>图论总结</center>

[toc]

### 图是什么？

![](https://raw.githubusercontent.com/Fierygit/picbed/master/20200219203748.png)

树可以存线， 图可以存树，树是一种无环图， 线是最简单的数据结构， 图是较为复杂的一种数据结构！



### 图的分类

|      |    有向    |    无向    |
| :--: | :--------: | :--------: |
| 有权 | 有向有权图 | 无向有权图 |
| 无权 | 有向无权图 | 无向无权图 |



### 图的表示

- 邻接矩阵

```c
int a[i][j] 
```

i点到j点的距离！ 空间复杂度： V^2 ,  求一个点的临接点:  V

- 邻接表（链表）

只存每个点能到达的点

空间复杂度： O（V+E  ），建图： O（E*V），求一个点的临接点：（O（V））

可以用 hash 或者 红黑树  替换 链表



### 图的遍历

#### DFS

- 树

分为 前序， （二叉树）中序， 后序， ==不用记录遍历过的点==！

- 图

分为 先序，后续（基本不用），要记录每一个每一个点是否遍历过， visited 记录

模版：

```c++
//code
```

```c++
// code
```

#### BFS

树的BFS和图的BFS是一样的！
**无权图的最短路径**

```c++
//code
```

#### 比较

做题最好用dfs， 不用中间队列存储太多东西！

栈（DFS），队列（BFS）， 随机容器（迷宫生成！）

```c++
//code 随机迷宫
```



#### 应用

- 求联通分量（图分成了多少块！？）

```c++
//code
```

- 路径问题（从一个点到另一个点是否通？）回溯

```c++
//code
```

- 检测环

```c++
//code
```

- 二分图检测

![](https://raw.githubusercontent.com/Fierygit/picbed/master/20200219211503.png)

定点V可以分为两部分， 所有边的两个顶点分别属于这两部分！ 

```c++
//code(染色)
```



#### floodfill算法

把图联通的某一部分填满！

游戏开发 -> 扫雷， 最大人工岛屿

```c++
//code
```



### 桥和隔点

> 桥： 删除了某一条边，联通分量发生改变！

![](https://raw.githubusercontent.com/Fierygit/picbed/master/20200219215253.png)

寻找所有桥！只有DFS可以求！(dfs遍历树)

对于每一条边 v - w ， 通过w， 能否通过另一条路回到v

```c++
//code  难
```



> 隔点： 删除隔点， 图的联通分量产生变化！

类似寻找桥的算法！

```c++
//code
```



### 欧拉回路和欧拉路径

哈密尔顿回路

从一个点出发， 经过**每个点一次**，回到原点

欧拉回路

从一条点出发， 经过**每一条边一次**， 回到原点

// 离散数学知识， 不会考

##### 状态压缩

 无权图可以直接使用**位**来存储图

### 最小生成树

#### 并查集

#### Kruskal

```c++

```

#### prim

```c++

```



### 最短路径

#### dijkstra和单源最短路径

无负数

```c++

```



#### Bellman-Ford

负数

```c++

```





#### Floyed-Warshall

所有点对最短路径





### 拓扑排序



```c++

```





### 网络流和最大流



#### Ford-Fulkerson



#### Edmonds-Karp





#### 匈牙利算法

BFS



DFS