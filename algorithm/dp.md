# <center> DP 题目汇总 </center>

记录一些遇到过的dp问题



DP(Dynamic Programming) 一种解决最优化问题的算法思想。

要求： **重叠子问题** && **最优子结构**



- 递归： 记忆化搜索

- 递推： 自底向上





[toc]

#### 比特位计数

> 给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。









#### 最大连续子序和

```c
dp[i] = max{A[i], dp[i-1] + A[i]}
```



#### 最长不下降子序列

```c
dp[i] = max{1, dp[j] + 1}  (贪心也可以)
```



#### 最长公共子序列（LCS）

```c
dp[i][j] = dp[i-1][j-1] + 1, A[i] == B[j]
    		max{dp[i-1][j], dp[i][j-1], A[i] != B[j]}
```



#### 最长回文子串

```c
dp[i][j] = dp[i+1][j-1], S[i] == S[j]
    		0, S[i] != S[j]
```



#### 01 背包问题

```c
d[i][v] = max{dp[i-1][v], dp[i-1][v-w[i]] + c[i]}
```



#### 完全背包问题

```c
dp[i][v] = max{dp[i-1], dp[i][v - w[i]] + c[i]}
```



#### 非相连最大和

```c
sum(k) = max(sum(k – 2) + A[k], sum(k – 1))
```



#### leetcode - dp中等专题

##### 60.不同的二叉搜索树

> 一组数据能够构成二叉树的最多的装填类型

*F*(*i*,*n*)=*G*(*i*−1)⋅*G*(*n*−*i*)

把一组数据看成左右和中间一点

##### 198.打家劫舍

> 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

dp[i + 2] = max(dp[i] + nums[i], dp[i+1]);

对于一家要么偷（取前两个之前最大的和加上前两个）， 要么不偷（取前面一个的就行了）



##### 740. 删除与获得点数

> 给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

nums = [2, 2, 3, 3, 3, 4]	变换一下	all=[0, 0, 2, 3, 1];

dp[i + 2] = max(dp[i] + i * nums[i], dp[i+1]);

和打家劫舍一样

##### 面试题 08.11. 硬币

> 给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。

```c
for (int c = 0; c < 4; ++c) {
    int coin = coins[c];
    for (int i = coin; i <= n; ++i) 
        f[i] = (f[i] + f[i - coin]) % mod;
}
```

##### 464. 我能赢吗

> 在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？

使用 dfs +  状态记忆就可以了, 太巧秒了

```c
void dfs(int cur){
	if(满足条件) return true;
	for(int i = 0; i < n; i++){
		if(!visited[i]) continue;
		if(dfs(cur + i)){// 注意这里是输的，状态反过来了
			return false;
		}
	}
    return false;
}
```



##### 523. 连续的子数组和

> 给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

1、 使用前缀和的方法，将 O（n^3） 优化为 O（n^ 2）

2、 很巧妙，记录所有前缀和的取余的数据

j --  i 如果是满足答案的， 那么， 前缀和 map[j % k] == map[i % k], 可以证明得到



##### 375. 猜数字大小 II

> 我们正在玩一个猜数游戏，游戏规则如下：我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。



##### 718. 最长重复子数组

>  给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

dp [i] [j] 表示A 从 i 和  B 从 j的最长的前缀和



##### 376. 摆动序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

摆动序列和一个数组的最大乘积和是一样的， 要记录两个状态！！！





##### 剑指 Offer 14- II. 剪绳子 II

> 给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m]` 。请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

这道题是一道数学题， 只要一直往3 减去就好了。



##### 983. 最低票价

> 难度中等237收藏分享切换为英文关注反馈

> 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days` 的数组给出。每一项是一个从 `1` 到 `365` 的整数。

> 火车票有三种不同的销售方式：

- 一张为期一天的通行证售价为 `costs[0]` 美元；
- 一张为期七天的通行证售价为 `costs[1]` 美元；
- 一张为期三十天的通行证售价为 `costs[2]` 美元。

> 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。

返回你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费。

我们用 dp*(*i*) 来表示从第  i  天开始到一年的结束，我们需要花的钱。



##### 221. 最大正方形

> 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

dp[i] [j] 表示在i, j 点的最大大正方形

dp 转移方程只要去左边，左上和上边最小的就可以了



##### 面试题 01.05. 一次编辑

> 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

dp[i] [j] 表示 第一个字符在 i， 第二个字符在 j 的时候编辑次数, 模拟出删除，替换，和拆入



##### 376. 摆动序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

和整数和一样，使用两个记录状态和， 也可以直接贪心， 因为前面的跟后面的没有关系，前面一个是上升的就接着找下一个下降的就行



##### 718. 最长重复子数组

> 给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

二维dp



##### 面试题 08.02. 迷路的机器人

> 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

可以使用 dfs 加上减枝， 也可以使用dfs，相当于 bfs



##### 面试题 17.06. 2出现的次数

> 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。

遍历每一位数字， 计算每一位数字大于2， 等于 2， 小于 2 的情况！



##### 1367. 二叉树中的列表

> 给你一棵以 `root` 为根的二叉树和一个 `head` 为第一个节点的链表。
>
> 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 `head` 为首的链表中每个节点的值，那么请你返回 `True` ，否则返回 `False` 。
>
> 一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

暴力， 没有什么难度



##### 95. 不同的二叉搜索树 II

>  给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的 **二叉搜索树** 。

太巧妙了！！！， 递归的优雅之处！！！， **看到停下来，** **再看一遍**

```c
vector<TreeNode*> helper(int start, int end) {
    if(start > end) return {nullptr};
    vector<TreeNode*> res;
    for(int i=start; i<=end; i++) {
        auto left = helper(start, i-1), right = helper(i+1, end);
        for(auto a:left) {
            for(auto b:right) {
                TreeNode* node = new TreeNode(i);
                node->left = a;
                node->right = b;
                res.push_back(node);
            }
        }
    }
    return res;
}
```





##### 1372. 二叉树中的最长交错路径

> 给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

```c
class Solution {
public:
    int maxAns;
    /* 0 => left, 1 => right */
    void dfs(TreeNode* o, bool dir, int len) {
        maxAns = max(maxAns, len);
        if (!dir) {
            if (o->left) dfs(o->left, 1, len + 1);
            if (o->right) dfs(o->right, 0, 1);
        } else {
            if (o->right) dfs(o->right, 0, len + 1);
            if (o->left) dfs(o->left, 1, 1);
        }
    } 

    int longestZigZag(TreeNode* root) {
        if (!root) return 0;
        maxAns = 0;
        dfs(root, 0, 0); dfs(root, 1, 0);
        return maxAns;
    }
};
```



##### 213. 打家劫舍 II

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

分位两种情况来计算dp！



##### 279. 完全平方数

> 给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

二维dp



##### 5. 最长回文子串

>  给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

dp[i] [j] 表示 从 i 到 j 是一个回文子串



##### 面试题 17.08. 马戏团人塔

有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。

```c
class Solution {
    using vint = vector<int>;
public:
    int bestSeqAtIndex(vector<int>& height, vector<int>& weight) {
        int len = height.size();
        vector<vint> k(len,vint(2,0));
        for(int i = 0; i < len; ++i) k[i][0] = height[i], k[i][1] = weight[i];        
        sort(k.begin(),k.end(),[](const vint& a,const vint& b){
            if(a[0] != b[0]) return a[0] < b[0];
            else return a[1] > b[1];
        });
        vint m(1,0);
        for(int i = 0; i < len; ++i){
            auto p = lower_bound(m.begin(),m.end(),k[i][1])-m.begin();
            if(p == m.size()) m.push_back(k[i][1]);
            else m[p] = k[i][1];
        }
        return m.size()-1;
    }
};
```



##### 516. 最长回文子序列

> 给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。

二维dp



##### 1143. 最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

二维dp



##### 801. 使序列递增的最小交换次数

> 我们有两个长度相等且不为空的整型数组 `A` 和 `B` 。
>
> 我们可以交换 `A[i]` 和 `B[i]` 的元素。注意这两个元素在各自的序列中应该处于相同的位置。
>
> 在交换过一些元素之后，数组 `A` 和 `B` 都应该是严格递增的（数组严格递增的条件仅为`A[0] < A[1] < A[2] < ... < A[A.length - 1]`）。
>
> 给定数组 `A` 和 `B` ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，